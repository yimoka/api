// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: common/common.proto

package common

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Num with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Num) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Num with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in NumMultiError, or nil if none found.
func (m *Num) ValidateAll() error {
	return m.validate(true)
}

func (m *Num) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	if len(errors) > 0 {
		return NumMultiError(errors)
	}

	return nil
}

// NumMultiError is an error wrapping multiple validation errors returned by
// Num.ValidateAll() if the designated constraints aren't met.
type NumMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NumMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NumMultiError) AllErrors() []error { return m }

// NumValidationError is the validation error returned by Num.Validate if the
// designated constraints aren't met.
type NumValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NumValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NumValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NumValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NumValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NumValidationError) ErrorName() string { return "NumValidationError" }

// Error satisfies the builtin error interface
func (e NumValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNum.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NumValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NumValidationError{}

// Validate checks the field values on BigNum with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BigNum) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BigNum with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in BigNumMultiError, or nil if none found.
func (m *BigNum) ValidateAll() error {
	return m.validate(true)
}

func (m *BigNum) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	if len(errors) > 0 {
		return BigNumMultiError(errors)
	}

	return nil
}

// BigNumMultiError is an error wrapping multiple validation errors returned by
// BigNum.ValidateAll() if the designated constraints aren't met.
type BigNumMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BigNumMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BigNumMultiError) AllErrors() []error { return m }

// BigNumValidationError is the validation error returned by BigNum.Validate if
// the designated constraints aren't met.
type BigNumValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BigNumValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BigNumValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BigNumValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BigNumValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BigNumValidationError) ErrorName() string { return "BigNumValidationError" }

// Error satisfies the builtin error interface
func (e BigNumValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBigNum.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BigNumValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BigNumValidationError{}

// Validate checks the field values on Bool with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Bool) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Bool with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in BoolMultiError, or nil if none found.
func (m *Bool) ValidateAll() error {
	return m.validate(true)
}

func (m *Bool) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	if len(errors) > 0 {
		return BoolMultiError(errors)
	}

	return nil
}

// BoolMultiError is an error wrapping multiple validation errors returned by
// Bool.ValidateAll() if the designated constraints aren't met.
type BoolMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BoolMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BoolMultiError) AllErrors() []error { return m }

// BoolValidationError is the validation error returned by Bool.Validate if the
// designated constraints aren't met.
type BoolValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BoolValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BoolValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BoolValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BoolValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BoolValidationError) ErrorName() string { return "BoolValidationError" }

// Error satisfies the builtin error interface
func (e BoolValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBool.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BoolValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BoolValidationError{}

// Validate checks the field values on Str with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Str) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Str with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in StrMultiError, or nil if none found.
func (m *Str) ValidateAll() error {
	return m.validate(true)
}

func (m *Str) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	if len(errors) > 0 {
		return StrMultiError(errors)
	}

	return nil
}

// StrMultiError is an error wrapping multiple validation errors returned by
// Str.ValidateAll() if the designated constraints aren't met.
type StrMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StrMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StrMultiError) AllErrors() []error { return m }

// StrValidationError is the validation error returned by Str.Validate if the
// designated constraints aren't met.
type StrValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StrValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StrValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StrValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StrValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StrValidationError) ErrorName() string { return "StrValidationError" }

// Error satisfies the builtin error interface
func (e StrValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStr.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StrValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StrValidationError{}

// Validate checks the field values on StrMap with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StrMap) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StrMap with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in StrMapMultiError, or nil if none found.
func (m *StrMap) ValidateAll() error {
	return m.validate(true)
}

func (m *StrMap) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	if len(errors) > 0 {
		return StrMapMultiError(errors)
	}

	return nil
}

// StrMapMultiError is an error wrapping multiple validation errors returned by
// StrMap.ValidateAll() if the designated constraints aren't met.
type StrMapMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StrMapMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StrMapMultiError) AllErrors() []error { return m }

// StrMapValidationError is the validation error returned by StrMap.Validate if
// the designated constraints aren't met.
type StrMapValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StrMapValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StrMapValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StrMapValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StrMapValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StrMapValidationError) ErrorName() string { return "StrMapValidationError" }

// Error satisfies the builtin error interface
func (e StrMapValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStrMap.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StrMapValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StrMapValidationError{}

// Validate checks the field values on NumMap with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NumMap) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NumMap with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in NumMapMultiError, or nil if none found.
func (m *NumMap) ValidateAll() error {
	return m.validate(true)
}

func (m *NumMap) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	if len(errors) > 0 {
		return NumMapMultiError(errors)
	}

	return nil
}

// NumMapMultiError is an error wrapping multiple validation errors returned by
// NumMap.ValidateAll() if the designated constraints aren't met.
type NumMapMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NumMapMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NumMapMultiError) AllErrors() []error { return m }

// NumMapValidationError is the validation error returned by NumMap.Validate if
// the designated constraints aren't met.
type NumMapValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NumMapValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NumMapValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NumMapValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NumMapValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NumMapValidationError) ErrorName() string { return "NumMapValidationError" }

// Error satisfies the builtin error interface
func (e NumMapValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNumMap.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NumMapValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NumMapValidationError{}

// Validate checks the field values on BigNumMap with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BigNumMap) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BigNumMap with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BigNumMapMultiError, or nil
// if none found.
func (m *BigNumMap) ValidateAll() error {
	return m.validate(true)
}

func (m *BigNumMap) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	if len(errors) > 0 {
		return BigNumMapMultiError(errors)
	}

	return nil
}

// BigNumMapMultiError is an error wrapping multiple validation errors returned
// by BigNumMap.ValidateAll() if the designated constraints aren't met.
type BigNumMapMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BigNumMapMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BigNumMapMultiError) AllErrors() []error { return m }

// BigNumMapValidationError is the validation error returned by
// BigNumMap.Validate if the designated constraints aren't met.
type BigNumMapValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BigNumMapValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BigNumMapValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BigNumMapValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BigNumMapValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BigNumMapValidationError) ErrorName() string { return "BigNumMapValidationError" }

// Error satisfies the builtin error interface
func (e BigNumMapValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBigNumMap.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BigNumMapValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BigNumMapValidationError{}

// Validate checks the field values on BoolMap with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BoolMap) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BoolMap with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in BoolMapMultiError, or nil if none found.
func (m *BoolMap) ValidateAll() error {
	return m.validate(true)
}

func (m *BoolMap) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	if len(errors) > 0 {
		return BoolMapMultiError(errors)
	}

	return nil
}

// BoolMapMultiError is an error wrapping multiple validation errors returned
// by BoolMap.ValidateAll() if the designated constraints aren't met.
type BoolMapMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BoolMapMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BoolMapMultiError) AllErrors() []error { return m }

// BoolMapValidationError is the validation error returned by BoolMap.Validate
// if the designated constraints aren't met.
type BoolMapValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BoolMapValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BoolMapValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BoolMapValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BoolMapValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BoolMapValidationError) ErrorName() string { return "BoolMapValidationError" }

// Error satisfies the builtin error interface
func (e BoolMapValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBoolMap.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BoolMapValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BoolMapValidationError{}

// Validate checks the field values on AnyMap with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AnyMap) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AnyMap with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in AnyMapMultiError, or nil if none found.
func (m *AnyMap) ValidateAll() error {
	return m.validate(true)
}

func (m *AnyMap) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AnyMapValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AnyMapValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AnyMapValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AnyMapMultiError(errors)
	}

	return nil
}

// AnyMapMultiError is an error wrapping multiple validation errors returned by
// AnyMap.ValidateAll() if the designated constraints aren't met.
type AnyMapMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AnyMapMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AnyMapMultiError) AllErrors() []error { return m }

// AnyMapValidationError is the validation error returned by AnyMap.Validate if
// the designated constraints aren't met.
type AnyMapValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AnyMapValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AnyMapValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AnyMapValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AnyMapValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AnyMapValidationError) ErrorName() string { return "AnyMapValidationError" }

// Error satisfies the builtin error interface
func (e AnyMapValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAnyMap.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AnyMapValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AnyMapValidationError{}

// Validate checks the field values on StrArray with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StrArray) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StrArray with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StrArrayMultiError, or nil
// if none found.
func (m *StrArray) ValidateAll() error {
	return m.validate(true)
}

func (m *StrArray) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return StrArrayMultiError(errors)
	}

	return nil
}

// StrArrayMultiError is an error wrapping multiple validation errors returned
// by StrArray.ValidateAll() if the designated constraints aren't met.
type StrArrayMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StrArrayMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StrArrayMultiError) AllErrors() []error { return m }

// StrArrayValidationError is the validation error returned by
// StrArray.Validate if the designated constraints aren't met.
type StrArrayValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StrArrayValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StrArrayValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StrArrayValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StrArrayValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StrArrayValidationError) ErrorName() string { return "StrArrayValidationError" }

// Error satisfies the builtin error interface
func (e StrArrayValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStrArray.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StrArrayValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StrArrayValidationError{}

// Validate checks the field values on NumArray with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NumArray) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NumArray with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NumArrayMultiError, or nil
// if none found.
func (m *NumArray) ValidateAll() error {
	return m.validate(true)
}

func (m *NumArray) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return NumArrayMultiError(errors)
	}

	return nil
}

// NumArrayMultiError is an error wrapping multiple validation errors returned
// by NumArray.ValidateAll() if the designated constraints aren't met.
type NumArrayMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NumArrayMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NumArrayMultiError) AllErrors() []error { return m }

// NumArrayValidationError is the validation error returned by
// NumArray.Validate if the designated constraints aren't met.
type NumArrayValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NumArrayValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NumArrayValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NumArrayValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NumArrayValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NumArrayValidationError) ErrorName() string { return "NumArrayValidationError" }

// Error satisfies the builtin error interface
func (e NumArrayValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNumArray.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NumArrayValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NumArrayValidationError{}

// Validate checks the field values on BigNumArray with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BigNumArray) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BigNumArray with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BigNumArrayMultiError, or
// nil if none found.
func (m *BigNumArray) ValidateAll() error {
	return m.validate(true)
}

func (m *BigNumArray) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return BigNumArrayMultiError(errors)
	}

	return nil
}

// BigNumArrayMultiError is an error wrapping multiple validation errors
// returned by BigNumArray.ValidateAll() if the designated constraints aren't met.
type BigNumArrayMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BigNumArrayMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BigNumArrayMultiError) AllErrors() []error { return m }

// BigNumArrayValidationError is the validation error returned by
// BigNumArray.Validate if the designated constraints aren't met.
type BigNumArrayValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BigNumArrayValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BigNumArrayValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BigNumArrayValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BigNumArrayValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BigNumArrayValidationError) ErrorName() string { return "BigNumArrayValidationError" }

// Error satisfies the builtin error interface
func (e BigNumArrayValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBigNumArray.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BigNumArrayValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BigNumArrayValidationError{}

// Validate checks the field values on BoolArray with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BoolArray) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BoolArray with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BoolArrayMultiError, or nil
// if none found.
func (m *BoolArray) ValidateAll() error {
	return m.validate(true)
}

func (m *BoolArray) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return BoolArrayMultiError(errors)
	}

	return nil
}

// BoolArrayMultiError is an error wrapping multiple validation errors returned
// by BoolArray.ValidateAll() if the designated constraints aren't met.
type BoolArrayMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BoolArrayMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BoolArrayMultiError) AllErrors() []error { return m }

// BoolArrayValidationError is the validation error returned by
// BoolArray.Validate if the designated constraints aren't met.
type BoolArrayValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BoolArrayValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BoolArrayValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BoolArrayValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BoolArrayValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BoolArrayValidationError) ErrorName() string { return "BoolArrayValidationError" }

// Error satisfies the builtin error interface
func (e BoolArrayValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBoolArray.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BoolArrayValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BoolArrayValidationError{}

// Validate checks the field values on Option with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Option) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Option with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in OptionMultiError, or nil if none found.
func (m *Option) ValidateAll() error {
	return m.validate(true)
}

func (m *Option) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	// no validation rules for Label

	if all {
		switch v := interface{}(m.GetExtra()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OptionValidationError{
					field:  "Extra",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OptionValidationError{
					field:  "Extra",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExtra()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OptionValidationError{
				field:  "Extra",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Desc != nil {
		// no validation rules for Desc
	}

	if m.Url != nil {
		// no validation rules for Url
	}

	if m.Img != nil {
		// no validation rules for Img
	}

	if m.Icon != nil {
		// no validation rules for Icon
	}

	if m.Color != nil {
		// no validation rules for Color
	}

	if m.Background != nil {
		// no validation rules for Background
	}

	if m.ActiveImg != nil {
		// no validation rules for ActiveImg
	}

	if m.ActiveIcon != nil {
		// no validation rules for ActiveIcon
	}

	if m.ActiveColor != nil {
		// no validation rules for ActiveColor
	}

	if m.ActiveBackground != nil {
		// no validation rules for ActiveBackground
	}

	if m.Disabled != nil {
		// no validation rules for Disabled
	}

	if len(errors) > 0 {
		return OptionMultiError(errors)
	}

	return nil
}

// OptionMultiError is an error wrapping multiple validation errors returned by
// Option.ValidateAll() if the designated constraints aren't met.
type OptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OptionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OptionMultiError) AllErrors() []error { return m }

// OptionValidationError is the validation error returned by Option.Validate if
// the designated constraints aren't met.
type OptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OptionValidationError) ErrorName() string { return "OptionValidationError" }

// Error satisfies the builtin error interface
func (e OptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOption.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OptionValidationError{}

// Validate checks the field values on Options with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Options) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Options with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in OptionsMultiError, or nil if none found.
func (m *Options) ValidateAll() error {
	return m.validate(true)
}

func (m *Options) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OptionsValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OptionsValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OptionsValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return OptionsMultiError(errors)
	}

	return nil
}

// OptionsMultiError is an error wrapping multiple validation errors returned
// by Options.ValidateAll() if the designated constraints aren't met.
type OptionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OptionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OptionsMultiError) AllErrors() []error { return m }

// OptionsValidationError is the validation error returned by Options.Validate
// if the designated constraints aren't met.
type OptionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OptionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OptionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OptionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OptionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OptionsValidationError) ErrorName() string { return "OptionsValidationError" }

// Error satisfies the builtin error interface
func (e OptionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOptions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OptionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OptionsValidationError{}

// Validate checks the field values on SortOrder with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SortOrder) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SortOrder with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SortOrderMultiError, or nil
// if none found.
func (m *SortOrder) ValidateAll() error {
	return m.validate(true)
}

func (m *SortOrder) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Field

	// no validation rules for Order

	if len(errors) > 0 {
		return SortOrderMultiError(errors)
	}

	return nil
}

// SortOrderMultiError is an error wrapping multiple validation errors returned
// by SortOrder.ValidateAll() if the designated constraints aren't met.
type SortOrderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SortOrderMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SortOrderMultiError) AllErrors() []error { return m }

// SortOrderValidationError is the validation error returned by
// SortOrder.Validate if the designated constraints aren't met.
type SortOrderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SortOrderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SortOrderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SortOrderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SortOrderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SortOrderValidationError) ErrorName() string { return "SortOrderValidationError" }

// Error satisfies the builtin error interface
func (e SortOrderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSortOrder.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SortOrderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SortOrderValidationError{}
