// Code generated by protoc-gen-go-errors. DO NOT EDIT.

package fault

import (
	fmt "fmt"
	errors "github.com/go-kratos/kratos/v2/errors"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
const _ = errors.SupportPackageIsVersion1

func IsBadRequest(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_BAD_REQUEST.String() && e.Code == 400
}

func ErrorBadRequest(format string, args ...interface{}) *errors.Error {
	return errors.New(400, ErrorReason_BAD_REQUEST.String(), fmt.Sprintf(format, args...))
}

// 微信 api 出错
func IsWeChatApiFailed(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_WE_CHAT_API_FAILED.String() && e.Code == 500
}

// 微信 api 出错
func ErrorWeChatApiFailed(format string, args ...interface{}) *errors.Error {
	return errors.New(500, ErrorReason_WE_CHAT_API_FAILED.String(), fmt.Sprintf(format, args...))
}

// 当前请求需要用户验证。
func IsUnauthorized(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_UNAUTHORIZED.String() && e.Code == 401
}

// 当前请求需要用户验证。
func ErrorUnauthorized(format string, args ...interface{}) *errors.Error {
	return errors.New(401, ErrorReason_UNAUTHORIZED.String(), fmt.Sprintf(format, args...))
}

// 此响应码保留以便将来使用，创造此响应码的最初目的是用于数字支付系统，然而现在并未使用
func IsPaymentRequired(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_PAYMENT_REQUIRED.String() && e.Code == 402
}

// 此响应码保留以便将来使用，创造此响应码的最初目的是用于数字支付系统，然而现在并未使用
func ErrorPaymentRequired(format string, args ...interface{}) *errors.Error {
	return errors.New(402, ErrorReason_PAYMENT_REQUIRED.String(), fmt.Sprintf(format, args...))
}

// 服务器已经理解请求，但是拒绝执行它。
func IsForbidden(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_FORBIDDEN.String() && e.Code == 403
}

// 服务器已经理解请求，但是拒绝执行它。
func ErrorForbidden(format string, args ...interface{}) *errors.Error {
	return errors.New(403, ErrorReason_FORBIDDEN.String(), fmt.Sprintf(format, args...))
}

// 请求失败，请求所希望得到的资源未被在服务器上发现。
func IsNotFound(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_NOT_FOUND.String() && e.Code == 404
}

// 请求失败，请求所希望得到的资源未被在服务器上发现。
func ErrorNotFound(format string, args ...interface{}) *errors.Error {
	return errors.New(404, ErrorReason_NOT_FOUND.String(), fmt.Sprintf(format, args...))
}

// 请求行中指定的请求方法不能被用于请求相应的资源。
func IsMethodNotAllowed(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_METHOD_NOT_ALLOWED.String() && e.Code == 405
}

// 请求行中指定的请求方法不能被用于请求相应的资源。
func ErrorMethodNotAllowed(format string, args ...interface{}) *errors.Error {
	return errors.New(405, ErrorReason_METHOD_NOT_ALLOWED.String(), fmt.Sprintf(format, args...))
}

// 请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。
func IsNotAcceptable(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_NOT_ACCEPTABLE.String() && e.Code == 406
}

// 请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。
func ErrorNotAcceptable(format string, args ...interface{}) *errors.Error {
	return errors.New(406, ErrorReason_NOT_ACCEPTABLE.String(), fmt.Sprintf(format, args...))
}

// 与401响应类似，只不过客户端必须在代理服务器上进行身份验证。
func IsProxyAuthenticationEquired(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_PROXY_AUTHENTICATION_EQUIRED.String() && e.Code == 407
}

// 与401响应类似，只不过客户端必须在代理服务器上进行身份验证。
func ErrorProxyAuthenticationEquired(format string, args ...interface{}) *errors.Error {
	return errors.New(407, ErrorReason_PROXY_AUTHENTICATION_EQUIRED.String(), fmt.Sprintf(format, args...))
}

// 请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。
func IsRequestTimeout(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_REQUEST_TIMEOUT.String() && e.Code == 408
}

// 请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。
func ErrorRequestTimeout(format string, args ...interface{}) *errors.Error {
	return errors.New(408, ErrorReason_REQUEST_TIMEOUT.String(), fmt.Sprintf(format, args...))
}

// 由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。
func IsConflict(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_CONFLICT.String() && e.Code == 409
}

// 由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。
func ErrorConflict(format string, args ...interface{}) *errors.Error {
	return errors.New(409, ErrorReason_CONFLICT.String(), fmt.Sprintf(format, args...))
}

// 被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。
func IsGone(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_GONE.String() && e.Code == 410
}

// 被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。
func ErrorGone(format string, args ...interface{}) *errors.Error {
	return errors.New(410, ErrorReason_GONE.String(), fmt.Sprintf(format, args...))
}

// 服务器拒绝在没有定义 Content-Length 头的情况下接受请求。
func IsLengthRequired(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_LENGTH_REQUIRED.String() && e.Code == 411
}

// 服务器拒绝在没有定义 Content-Length 头的情况下接受请求。
func ErrorLengthRequired(format string, args ...interface{}) *errors.Error {
	return errors.New(411, ErrorReason_LENGTH_REQUIRED.String(), fmt.Sprintf(format, args...))
}

// 服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。
func IsPreconditionFailed(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_PRECONDITION_FAILED.String() && e.Code == 412
}

// 服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。
func ErrorPreconditionFailed(format string, args ...interface{}) *errors.Error {
	return errors.New(412, ErrorReason_PRECONDITION_FAILED.String(), fmt.Sprintf(format, args...))
}

// 服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。
func IsPayloadTooLarge(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_PAYLOAD_TOO_LARGE.String() && e.Code == 413
}

// 服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。
func ErrorPayloadTooLarge(format string, args ...interface{}) *errors.Error {
	return errors.New(413, ErrorReason_PAYLOAD_TOO_LARGE.String(), fmt.Sprintf(format, args...))
}

// 请求的URI长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。
func IsUriTooLong(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_URI_TOO_LONG.String() && e.Code == 414
}

// 请求的URI长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。
func ErrorUriTooLong(format string, args ...interface{}) *errors.Error {
	return errors.New(414, ErrorReason_URI_TOO_LONG.String(), fmt.Sprintf(format, args...))
}

// 对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。
func IsUnsupportedMediaType(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_UNSUPPORTED_MEDIA_TYPE.String() && e.Code == 415
}

// 对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。
func ErrorUnsupportedMediaType(format string, args ...interface{}) *errors.Error {
	return errors.New(415, ErrorReason_UNSUPPORTED_MEDIA_TYPE.String(), fmt.Sprintf(format, args...))
}

// 如果请求中包含了 Range
// 请求头，并且Range中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义
// If-Range 请求头，那么服务器就应当返回416状态码。
func IsRangeNotSatisfiable(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_RANGE_NOT_SATISFIABLE.String() && e.Code == 416
}

// 如果请求中包含了 Range
// 请求头，并且Range中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义
// If-Range 请求头，那么服务器就应当返回416状态码。
func ErrorRangeNotSatisfiable(format string, args ...interface{}) *errors.Error {
	return errors.New(416, ErrorReason_RANGE_NOT_SATISFIABLE.String(), fmt.Sprintf(format, args...))
}

// 此响应代码意味着服务器无法满足 EXPECT 请求标头字段指示的期望值。
func IsExpectationFailed(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_EXPECTATION_FAILED.String() && e.Code == 417
}

// 此响应代码意味着服务器无法满足 EXPECT 请求标头字段指示的期望值。
func ErrorExpectationFailed(format string, args ...interface{}) *errors.Error {
	return errors.New(417, ErrorReason_EXPECTATION_FAILED.String(), fmt.Sprintf(format, args...))
}

// 服务器拒绝尝试用 “茶壶冲泡咖啡”。
func IsImATeapot(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_IM_A_TEAPOT.String() && e.Code == 418
}

// 服务器拒绝尝试用 “茶壶冲泡咖啡”。
func ErrorImATeapot(format string, args ...interface{}) *errors.Error {
	return errors.New(418, ErrorReason_IM_A_TEAPOT.String(), fmt.Sprintf(format, args...))
}

// 该请求针对的是无法产生响应的服务器这可以由服务器发送，该服务器未配置为针对包含在请求URI中的方案和权限的组合产生响应
func IsMisdirectedRequest(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_MISDIRECTED_REQUEST.String() && e.Code == 421
}

// 该请求针对的是无法产生响应的服务器这可以由服务器发送，该服务器未配置为针对包含在请求URI中的方案和权限的组合产生响应
func ErrorMisdirectedRequest(format string, args ...interface{}) *errors.Error {
	return errors.New(421, ErrorReason_MISDIRECTED_REQUEST.String(), fmt.Sprintf(format, args...))
}

// 请求格式良好，但由于语义错误而无法遵循。
func IsUnprocessableEntity(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_UNPROCESSABLE_ENTITY.String() && e.Code == 422
}

// 请求格式良好，但由于语义错误而无法遵循。
func ErrorUnprocessableEntity(format string, args ...interface{}) *errors.Error {
	return errors.New(422, ErrorReason_UNPROCESSABLE_ENTITY.String(), fmt.Sprintf(format, args...))
}

// 正在访问的资源被锁定。
func IsLocked(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_LOCKED.String() && e.Code == 423
}

// 正在访问的资源被锁定。
func ErrorLocked(format string, args ...interface{}) *errors.Error {
	return errors.New(423, ErrorReason_LOCKED.String(), fmt.Sprintf(format, args...))
}

// 由于先前的请求失败，所以此次请求失败。
func IsFailedDependency(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_FAILED_DEPENDENCY.String() && e.Code == 424
}

// 由于先前的请求失败，所以此次请求失败。
func ErrorFailedDependency(format string, args ...interface{}) *errors.Error {
	return errors.New(424, ErrorReason_FAILED_DEPENDENCY.String(), fmt.Sprintf(format, args...))
}

// 服务器不愿意冒着风险去处理可能重播的请求。
func IsTooEarly(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_Too_Early.String() && e.Code == 425
}

// 服务器不愿意冒着风险去处理可能重播的请求。
func ErrorTooEarly(format string, args ...interface{}) *errors.Error {
	return errors.New(425, ErrorReason_Too_Early.String(), fmt.Sprintf(format, args...))
}

// 服务器拒绝使用当前协议执行请求
func IsUpgradeRequired(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_UPGRADE_REQUIRED.String() && e.Code == 426
}

// 服务器拒绝使用当前协议执行请求
func ErrorUpgradeRequired(format string, args ...interface{}) *errors.Error {
	return errors.New(426, ErrorReason_UPGRADE_REQUIRED.String(), fmt.Sprintf(format, args...))
}

// 原始服务器要求该请求是有条件的。
// 旨在防止“丢失更新”问题，即客户端获取资源状态，修改该状态并将其返回服务器，同时第三方修改服务器上的状态，从而导致冲突。
func IsPreconditionRequired(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_PRECONDITION_REQUIRED.String() && e.Code == 428
}

// 原始服务器要求该请求是有条件的。
// 旨在防止“丢失更新”问题，即客户端获取资源状态，修改该状态并将其返回服务器，同时第三方修改服务器上的状态，从而导致冲突。
func ErrorPreconditionRequired(format string, args ...interface{}) *errors.Error {
	return errors.New(428, ErrorReason_PRECONDITION_REQUIRED.String(), fmt.Sprintf(format, args...))
}

// 用户在给定的时间内发送了太多请求（“限制请求速率”）。
func IsTooManyRequests(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_TOO_MANY_REQUESTS.String() && e.Code == 429
}

// 用户在给定的时间内发送了太多请求（“限制请求速率”）。
func ErrorTooManyRequests(format string, args ...interface{}) *errors.Error {
	return errors.New(429, ErrorReason_TOO_MANY_REQUESTS.String(), fmt.Sprintf(format, args...))
}

// 服务器不愿意处理请求，因为它的 请求头字段太大
func IsRequestHeaderFieldsTooLarge(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_REQUEST_HEADER_FIELDS_TOO_LARGE.String() && e.Code == 431
}

// 服务器不愿意处理请求，因为它的 请求头字段太大
func ErrorRequestHeaderFieldsTooLarge(format string, args ...interface{}) *errors.Error {
	return errors.New(431, ErrorReason_REQUEST_HEADER_FIELDS_TOO_LARGE.String(), fmt.Sprintf(format, args...))
}

// 用户请求非法资源，例如：由政府审查的网页。
func IsUnavailableForLegalReasons(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_UNAVAILABLE_FOR_LEGAL_REASONS.String() && e.Code == 451
}

// 用户请求非法资源，例如：由政府审查的网页。
func ErrorUnavailableForLegalReasons(format string, args ...interface{}) *errors.Error {
	return errors.New(451, ErrorReason_UNAVAILABLE_FOR_LEGAL_REASONS.String(), fmt.Sprintf(format, args...))
}

// 服务器遇到了不知道如何处理的情况
func IsInternalServerError(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_INTERNAL_SERVER_ERROR.String() && e.Code == 500
}

// 服务器遇到了不知道如何处理的情况
func ErrorInternalServerError(format string, args ...interface{}) *errors.Error {
	return errors.New(500, ErrorReason_INTERNAL_SERVER_ERROR.String(), fmt.Sprintf(format, args...))
}

// 此请求方法不被服务器支持且无法被处理。只有GET和HEAD是要求服务器支持的，它们必定不会返回此错误代码
func IsNotImplemented(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_NOT_IMPLEMENTED.String() && e.Code == 501
}

// 此请求方法不被服务器支持且无法被处理。只有GET和HEAD是要求服务器支持的，它们必定不会返回此错误代码
func ErrorNotImplemented(format string, args ...interface{}) *errors.Error {
	return errors.New(501, ErrorReason_NOT_IMPLEMENTED.String(), fmt.Sprintf(format, args...))
}

// 此错误响应表明服务器作为网关需要得到一个处理这个请求的响应，但是得到一个错误的响应
func IsBadGateway(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_BAD_GATEWAY.String() && e.Code == 502
}

// 此错误响应表明服务器作为网关需要得到一个处理这个请求的响应，但是得到一个错误的响应
func ErrorBadGateway(format string, args ...interface{}) *errors.Error {
	return errors.New(502, ErrorReason_BAD_GATEWAY.String(), fmt.Sprintf(format, args...))
}

// 服务器没有准备好处理请求。 常见原因是服务器因维护或重载而停机。
func IsServiceUnavailable(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_SERVICE_UNAVAILABLE.String() && e.Code == 503
}

// 服务器没有准备好处理请求。 常见原因是服务器因维护或重载而停机。
func ErrorServiceUnavailable(format string, args ...interface{}) *errors.Error {
	return errors.New(503, ErrorReason_SERVICE_UNAVAILABLE.String(), fmt.Sprintf(format, args...))
}

// 当服务器作为网关，不能及时得到响应时返回此错误代码。
func IsGatewayTimeout(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_GATEWAY_TIMEOUT.String() && e.Code == 504
}

// 当服务器作为网关，不能及时得到响应时返回此错误代码。
func ErrorGatewayTimeout(format string, args ...interface{}) *errors.Error {
	return errors.New(504, ErrorReason_GATEWAY_TIMEOUT.String(), fmt.Sprintf(format, args...))
}

// 服务器不支持请求中所使用的HTTP协议版本。
func IsHttpVersionNotSupported(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_HTTP_VERSION_NOT_SUPPORTED.String() && e.Code == 505
}

// 服务器不支持请求中所使用的HTTP协议版本。
func ErrorHttpVersionNotSupported(format string, args ...interface{}) *errors.Error {
	return errors.New(505, ErrorReason_HTTP_VERSION_NOT_SUPPORTED.String(), fmt.Sprintf(format, args...))
}

// 服务器有一个内部配置错误：对请求的透明内容协商导致循环引用
func IsVariantAlsoNegotiates(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_VARIANT_ALSO_NEGOTIATES.String() && e.Code == 506
}

// 服务器有一个内部配置错误：对请求的透明内容协商导致循环引用
func ErrorVariantAlsoNegotiates(format string, args ...interface{}) *errors.Error {
	return errors.New(506, ErrorReason_VARIANT_ALSO_NEGOTIATES.String(), fmt.Sprintf(format, args...))
}

// 服务器有内部配置错误：所选的变体资源被配置为参与透明内容协商本身，因此不是协商过程中的适当端点。
func IsInsufficientStorage(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_INSUFFICIENT_STORAGE.String() && e.Code == 507
}

// 服务器有内部配置错误：所选的变体资源被配置为参与透明内容协商本身，因此不是协商过程中的适当端点。
func ErrorInsufficientStorage(format string, args ...interface{}) *errors.Error {
	return errors.New(507, ErrorReason_INSUFFICIENT_STORAGE.String(), fmt.Sprintf(format, args...))
}

// 服务器在处理请求时检测到无限循环
func IsLoopDetected(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_LOOP_DETECTED.String() && e.Code == 508
}

// 服务器在处理请求时检测到无限循环
func ErrorLoopDetected(format string, args ...interface{}) *errors.Error {
	return errors.New(508, ErrorReason_LOOP_DETECTED.String(), fmt.Sprintf(format, args...))
}

// 客户端需要对请求进一步扩展，服务器才能实现它。服务器会回复客户端发出扩展请求所需的所有信息。
func IsNotExtended(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_NOT_EXTENDED.String() && e.Code == 510
}

// 客户端需要对请求进一步扩展，服务器才能实现它。服务器会回复客户端发出扩展请求所需的所有信息。
func ErrorNotExtended(format string, args ...interface{}) *errors.Error {
	return errors.New(510, ErrorReason_NOT_EXTENDED.String(), fmt.Sprintf(format, args...))
}

// 状态码指示客户端需要进行身份验证才能获得网络访问权限。
func IsNetworkAuthenticationRequired(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_NETWORK_AUTHENTICATION_REQUIRED.String() && e.Code == 511
}

// 状态码指示客户端需要进行身份验证才能获得网络访问权限。
func ErrorNetworkAuthenticationRequired(format string, args ...interface{}) *errors.Error {
	return errors.New(511, ErrorReason_NETWORK_AUTHENTICATION_REQUIRED.String(), fmt.Sprintf(format, args...))
}
